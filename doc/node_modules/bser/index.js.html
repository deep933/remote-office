<!DOCTYPE html>
<html>
<head>
  <title>index.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../doc-style.css" />
  <script src="../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../";
    var thisFile = "node_modules/bser/index.js";
    var defaultSidebar = true;
  </script>
  <script src="../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>index.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright 2015-present Facebook, Inc.
Licensed under the Apache License, Version 2.0</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
<span class="hljs-keyword">var</span> EE = <span class="hljs-built_in">require</span>(<span class="hljs-string">'events'</span>).EventEmitter;
<span class="hljs-keyword">var</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">'util'</span>);
<span class="hljs-keyword">var</span> os = <span class="hljs-built_in">require</span>(<span class="hljs-string">'os'</span>);
<span class="hljs-keyword">var</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">'assert'</span>);
<span class="hljs-keyword">var</span> Int64 = <span class="hljs-built_in">require</span>(<span class="hljs-string">'node-int64'</span>);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<p>BSER uses the local endianness to reduce byte swapping overheads
(the protocol is expressly local IPC only).  We need to tell node
to use the native endianness when reading various native values.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> isBigEndian = os.endianness() == <span class="hljs-string">'BE'</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<p>Find the next power-of-2 &gt;= size</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nextPow2</span>(<span class="hljs-params">size</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-built_in">Math</span>.ceil(<span class="hljs-built_in">Math</span>.log(size) / <span class="hljs-built_in">Math</span>.LN2));
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p>Expandable buffer that we can provide a size hint for</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Accumulator</span>(<span class="hljs-params">initsize</span>) </span>{
  <span class="hljs-keyword">this</span>.buf = Buffer.alloc(nextPow2(initsize || <span class="hljs-number">8192</span>));
  <span class="hljs-keyword">this</span>.readOffset = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">this</span>.writeOffset = <span class="hljs-number">0</span>;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<p>For testing</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">exports.Accumulator = Accumulator

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<p>How much we can write into this buffer without allocating</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">Accumulator.prototype.writeAvail = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.buf.length - <span class="hljs-keyword">this</span>.writeOffset;
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<p>How much we can read</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">Accumulator.prototype.readAvail = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.writeOffset - <span class="hljs-keyword">this</span>.readOffset;
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-8" id="section-8"></a>
</div>
<p>Ensure that we have enough space for size bytes</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">Accumulator.prototype.reserve = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">size</span>) </span>{
  <span class="hljs-keyword">if</span> (size &lt; <span class="hljs-keyword">this</span>.writeAvail()) {
    <span class="hljs-keyword">return</span>;
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-9" id="section-9"></a>
</div>
<p>If we can make room by shunting down, do so</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.readOffset &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">this</span>.buf.copy(<span class="hljs-keyword">this</span>.buf, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>.readOffset, <span class="hljs-keyword">this</span>.writeOffset);
    <span class="hljs-keyword">this</span>.writeOffset -= <span class="hljs-keyword">this</span>.readOffset;
    <span class="hljs-keyword">this</span>.readOffset = <span class="hljs-number">0</span>;
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-10" id="section-10"></a>
</div>
<p>If we made enough room, no need to allocate more</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">if</span> (size &lt; <span class="hljs-keyword">this</span>.writeAvail()) {
    <span class="hljs-keyword">return</span>;
  }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-11" id="section-11"></a>
</div>
<p>Allocate a replacement and copy it in</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> buf = Buffer.alloc(nextPow2(<span class="hljs-keyword">this</span>.buf.length + size - <span class="hljs-keyword">this</span>.writeAvail()));
  <span class="hljs-keyword">this</span>.buf.copy(buf);
  <span class="hljs-keyword">this</span>.buf = buf;
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-12" id="section-12"></a>
</div>
<p>Append buffer or string.  Will resize as needed</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">Accumulator.prototype.append = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">buf</span>) </span>{
  <span class="hljs-keyword">if</span> (Buffer.isBuffer(buf)) {
    <span class="hljs-keyword">this</span>.reserve(buf.length);
    buf.copy(<span class="hljs-keyword">this</span>.buf, <span class="hljs-keyword">this</span>.writeOffset, <span class="hljs-number">0</span>, buf.length);
    <span class="hljs-keyword">this</span>.writeOffset += buf.length;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">var</span> size = Buffer.byteLength(buf);
    <span class="hljs-keyword">this</span>.reserve(size);
    <span class="hljs-keyword">this</span>.buf.write(buf, <span class="hljs-keyword">this</span>.writeOffset);
    <span class="hljs-keyword">this</span>.writeOffset += size;
  }
}

Accumulator.prototype.assertReadableSize = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">size</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.readAvail() &lt; size) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"wanted to read "</span> + size +
        <span class="hljs-string">" bytes but only have "</span> + <span class="hljs-keyword">this</span>.readAvail());
  }
}

Accumulator.prototype.peekString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">size</span>) </span>{
  <span class="hljs-keyword">this</span>.assertReadableSize(size);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.buf.toString(<span class="hljs-string">'utf-8'</span>, <span class="hljs-keyword">this</span>.readOffset, <span class="hljs-keyword">this</span>.readOffset + size);
}

Accumulator.prototype.readString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">size</span>) </span>{
  <span class="hljs-keyword">var</span> str = <span class="hljs-keyword">this</span>.peekString(size);
  <span class="hljs-keyword">this</span>.readOffset += size;
  <span class="hljs-keyword">return</span> str;
}

Accumulator.prototype.peekInt = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">size</span>) </span>{
  <span class="hljs-keyword">this</span>.assertReadableSize(size);
  <span class="hljs-keyword">switch</span> (size) {
    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.buf.readInt8(<span class="hljs-keyword">this</span>.readOffset, size);
    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
      <span class="hljs-keyword">return</span> isBigEndian ?
        <span class="hljs-keyword">this</span>.buf.readInt16BE(<span class="hljs-keyword">this</span>.readOffset, size) :
        <span class="hljs-keyword">this</span>.buf.readInt16LE(<span class="hljs-keyword">this</span>.readOffset, size);
    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:
      <span class="hljs-keyword">return</span> isBigEndian ?
        <span class="hljs-keyword">this</span>.buf.readInt32BE(<span class="hljs-keyword">this</span>.readOffset, size) :
        <span class="hljs-keyword">this</span>.buf.readInt32LE(<span class="hljs-keyword">this</span>.readOffset, size);
    <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:
        <span class="hljs-keyword">var</span> big = <span class="hljs-keyword">this</span>.buf.slice(<span class="hljs-keyword">this</span>.readOffset, <span class="hljs-keyword">this</span>.readOffset + <span class="hljs-number">8</span>);
        <span class="hljs-keyword">if</span> (isBigEndian) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-13" id="section-13"></a>
</div>
<p>On a big endian system we can simply pass the buffer directly</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Int64(big);
        }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-14" id="section-14"></a>
</div>
<p>Otherwise we need to byteswap</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Int64(byteswap64(big));
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"invalid integer size "</span> + size);
  }
}

Accumulator.prototype.readInt = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">bytes</span>) </span>{
  <span class="hljs-keyword">var</span> ival = <span class="hljs-keyword">this</span>.peekInt(bytes);
  <span class="hljs-keyword">if</span> (ival <span class="hljs-keyword">instanceof</span> Int64 &amp;&amp; <span class="hljs-built_in">isFinite</span>(ival.valueOf())) {
    ival = ival.valueOf();
  }
  <span class="hljs-keyword">this</span>.readOffset += bytes;
  <span class="hljs-keyword">return</span> ival;
}

Accumulator.prototype.peekDouble = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.assertReadableSize(<span class="hljs-number">8</span>);
  <span class="hljs-keyword">return</span> isBigEndian ?
    <span class="hljs-keyword">this</span>.buf.readDoubleBE(<span class="hljs-keyword">this</span>.readOffset) :
    <span class="hljs-keyword">this</span>.buf.readDoubleLE(<span class="hljs-keyword">this</span>.readOffset);
}

Accumulator.prototype.readDouble = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> dval = <span class="hljs-keyword">this</span>.peekDouble();
  <span class="hljs-keyword">this</span>.readOffset += <span class="hljs-number">8</span>;
  <span class="hljs-keyword">return</span> dval;
}

Accumulator.prototype.readAdvance = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">size</span>) </span>{
  <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">this</span>.assertReadableSize(size);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (size &lt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">this</span>.readOffset + size &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"advance with negative offset "</span> + size +
        <span class="hljs-string">" would seek off the start of the buffer"</span>);
  }
  <span class="hljs-keyword">this</span>.readOffset += size;
}

Accumulator.prototype.writeByte = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
  <span class="hljs-keyword">this</span>.reserve(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">this</span>.buf.writeInt8(value, <span class="hljs-keyword">this</span>.writeOffset);
  ++<span class="hljs-keyword">this</span>.writeOffset;
}

Accumulator.prototype.writeInt = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, size</span>) </span>{
  <span class="hljs-keyword">this</span>.reserve(size);
  <span class="hljs-keyword">switch</span> (size) {
    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
      <span class="hljs-keyword">this</span>.buf.writeInt8(value, <span class="hljs-keyword">this</span>.writeOffset);
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
      <span class="hljs-keyword">if</span> (isBigEndian) {
        <span class="hljs-keyword">this</span>.buf.writeInt16BE(value, <span class="hljs-keyword">this</span>.writeOffset);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">this</span>.buf.writeInt16LE(value, <span class="hljs-keyword">this</span>.writeOffset);
      }
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:
      <span class="hljs-keyword">if</span> (isBigEndian) {
        <span class="hljs-keyword">this</span>.buf.writeInt32BE(value, <span class="hljs-keyword">this</span>.writeOffset);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">this</span>.buf.writeInt32LE(value, <span class="hljs-keyword">this</span>.writeOffset);
      }
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"unsupported integer size "</span> + size);
  }
  <span class="hljs-keyword">this</span>.writeOffset += size;
}

Accumulator.prototype.writeDouble = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
  <span class="hljs-keyword">this</span>.reserve(<span class="hljs-number">8</span>);
  <span class="hljs-keyword">if</span> (isBigEndian) {
    <span class="hljs-keyword">this</span>.buf.writeDoubleBE(value, <span class="hljs-keyword">this</span>.writeOffset);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">this</span>.buf.writeDoubleLE(value, <span class="hljs-keyword">this</span>.writeOffset);
  }
  <span class="hljs-keyword">this</span>.writeOffset += <span class="hljs-number">8</span>;
}

<span class="hljs-keyword">var</span> BSER_ARRAY     = <span class="hljs-number">0x00</span>;
<span class="hljs-keyword">var</span> BSER_OBJECT    = <span class="hljs-number">0x01</span>;
<span class="hljs-keyword">var</span> BSER_STRING    = <span class="hljs-number">0x02</span>;
<span class="hljs-keyword">var</span> BSER_INT8      = <span class="hljs-number">0x03</span>;
<span class="hljs-keyword">var</span> BSER_INT16     = <span class="hljs-number">0x04</span>;
<span class="hljs-keyword">var</span> BSER_INT32     = <span class="hljs-number">0x05</span>;
<span class="hljs-keyword">var</span> BSER_INT64     = <span class="hljs-number">0x06</span>;
<span class="hljs-keyword">var</span> BSER_REAL      = <span class="hljs-number">0x07</span>;
<span class="hljs-keyword">var</span> BSER_TRUE      = <span class="hljs-number">0x08</span>;
<span class="hljs-keyword">var</span> BSER_FALSE     = <span class="hljs-number">0x09</span>;
<span class="hljs-keyword">var</span> BSER_NULL      = <span class="hljs-number">0x0a</span>;
<span class="hljs-keyword">var</span> BSER_TEMPLATE  = <span class="hljs-number">0x0b</span>;
<span class="hljs-keyword">var</span> BSER_SKIP      = <span class="hljs-number">0x0c</span>;

<span class="hljs-keyword">var</span> ST_NEED_PDU = <span class="hljs-number">0</span>; <span class="hljs-comment">// Need to read and decode PDU length</span>
<span class="hljs-keyword">var</span> ST_FILL_PDU = <span class="hljs-number">1</span>; <span class="hljs-comment">// Know the length, need to read whole content</span>

<span class="hljs-keyword">var</span> MAX_INT8 = <span class="hljs-number">127</span>;
<span class="hljs-keyword">var</span> MAX_INT16 = <span class="hljs-number">32767</span>;
<span class="hljs-keyword">var</span> MAX_INT32 = <span class="hljs-number">2147483647</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BunserBuf</span>(<span class="hljs-params"></span>) </span>{
  EE.call(<span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">this</span>.buf = <span class="hljs-keyword">new</span> Accumulator();
  <span class="hljs-keyword">this</span>.state = ST_NEED_PDU;
}
util.inherits(BunserBuf, EE);
exports.BunserBuf = BunserBuf;

BunserBuf.prototype.append = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">buf, synchronous</span>) </span>{
  <span class="hljs-keyword">if</span> (synchronous) {
    <span class="hljs-keyword">this</span>.buf.append(buf);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.process(synchronous);
  }

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">this</span>.buf.append(buf);
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'error'</span>, err);
    <span class="hljs-keyword">return</span>;
  }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-15" id="section-15"></a>
</div>
<p>Arrange to decode later.  This allows the consuming
application to make progress with other work in the
case that we have a lot of subscription updates coming
in from a large tree.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">this</span>.processLater();
}

BunserBuf.prototype.processLater = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
  process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">try</span> {
      self.process(<span class="hljs-literal">false</span>);
    } <span class="hljs-keyword">catch</span> (err) {
      self.emit(<span class="hljs-string">'error'</span>, err);
    }
  });
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-16" id="section-16"></a>
</div>
<p>Do something with the buffer to advance our state.
If we're running synchronously we'll return either
the value we've decoded or undefined if we don't
yet have enought data.
If we're running asynchronously, we'll emit the value
when it becomes ready and schedule another invocation
of process on the next tick if we still have data we
can process.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">BunserBuf.prototype.process = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">synchronous</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state == ST_NEED_PDU) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.buf.readAvail() &lt; <span class="hljs-number">2</span>) {
      <span class="hljs-keyword">return</span>;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-17" id="section-17"></a>
</div>
<p>Validate BSER header</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">this</span>.expectCode(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">this</span>.expectCode(<span class="hljs-number">1</span>);
    <span class="hljs-keyword">this</span>.pduLen = <span class="hljs-keyword">this</span>.decodeInt(<span class="hljs-literal">true</span> <span class="hljs-comment">/* relaxed */</span>);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.pduLen === <span class="hljs-literal">false</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-18" id="section-18"></a>
</div>
<p>Need more data, walk backwards</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">this</span>.buf.readAdvance(<span class="hljs-number">-2</span>);
      <span class="hljs-keyword">return</span>;
    }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-19" id="section-19"></a>
</div>
<p>Ensure that we have a big enough buffer to read the rest of the PDU</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">this</span>.buf.reserve(<span class="hljs-keyword">this</span>.pduLen);
    <span class="hljs-keyword">this</span>.state = ST_FILL_PDU;
  }

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state == ST_FILL_PDU) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.buf.readAvail() &lt; <span class="hljs-keyword">this</span>.pduLen) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-20" id="section-20"></a>
</div>
<p>Need more data</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">return</span>;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-21" id="section-21"></a>
</div>
<p>We have enough to decode it</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> val = <span class="hljs-keyword">this</span>.decodeAny();
    <span class="hljs-keyword">if</span> (synchronous) {
      <span class="hljs-keyword">return</span> val;
    }
    <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'value'</span>, val);
    <span class="hljs-keyword">this</span>.state = ST_NEED_PDU;
  }

  <span class="hljs-keyword">if</span> (!synchronous &amp;&amp; <span class="hljs-keyword">this</span>.buf.readAvail() &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">this</span>.processLater();
  }
}

BunserBuf.prototype.raise = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>) </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(reason + <span class="hljs-string">", in Buffer of length "</span> +
      <span class="hljs-keyword">this</span>.buf.buf.length + <span class="hljs-string">" ("</span> + <span class="hljs-keyword">this</span>.buf.readAvail() +
      <span class="hljs-string">" readable) at offset "</span> + <span class="hljs-keyword">this</span>.buf.readOffset + <span class="hljs-string">" buffer: "</span> +
      <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-keyword">this</span>.buf.buf.slice(
          <span class="hljs-keyword">this</span>.buf.readOffset, <span class="hljs-keyword">this</span>.buf.readOffset + <span class="hljs-number">32</span>).toJSON()));
}

BunserBuf.prototype.expectCode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">expected</span>) </span>{
  <span class="hljs-keyword">var</span> code = <span class="hljs-keyword">this</span>.buf.readInt(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">if</span> (code != expected) {
    <span class="hljs-keyword">this</span>.raise(<span class="hljs-string">"expected bser opcode "</span> + expected + <span class="hljs-string">" but got "</span> + code);
  }
}

BunserBuf.prototype.decodeAny = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> code = <span class="hljs-keyword">this</span>.buf.peekInt(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">switch</span> (code) {
    <span class="hljs-keyword">case</span> BSER_INT8:
    <span class="hljs-keyword">case</span> BSER_INT16:
    <span class="hljs-keyword">case</span> BSER_INT32:
    <span class="hljs-keyword">case</span> BSER_INT64:
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.decodeInt();
    <span class="hljs-keyword">case</span> BSER_REAL:
      <span class="hljs-keyword">this</span>.buf.readAdvance(<span class="hljs-number">1</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.buf.readDouble();
    <span class="hljs-keyword">case</span> BSER_TRUE:
      <span class="hljs-keyword">this</span>.buf.readAdvance(<span class="hljs-number">1</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">case</span> BSER_FALSE:
      <span class="hljs-keyword">this</span>.buf.readAdvance(<span class="hljs-number">1</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">case</span> BSER_NULL:
      <span class="hljs-keyword">this</span>.buf.readAdvance(<span class="hljs-number">1</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">case</span> BSER_STRING:
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.decodeString();
    <span class="hljs-keyword">case</span> BSER_ARRAY:
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.decodeArray();
    <span class="hljs-keyword">case</span> BSER_OBJECT:
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.decodeObject();
    <span class="hljs-keyword">case</span> BSER_TEMPLATE:
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.decodeTemplate();
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">this</span>.raise(<span class="hljs-string">"unhandled bser opcode "</span> + code);
  }
}

BunserBuf.prototype.decodeArray = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.expectCode(BSER_ARRAY);
  <span class="hljs-keyword">var</span> nitems = <span class="hljs-keyword">this</span>.decodeInt();
  <span class="hljs-keyword">var</span> arr = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; nitems; ++i) {
    arr.push(<span class="hljs-keyword">this</span>.decodeAny());
  }
  <span class="hljs-keyword">return</span> arr;
}

BunserBuf.prototype.decodeObject = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.expectCode(BSER_OBJECT);
  <span class="hljs-keyword">var</span> nitems = <span class="hljs-keyword">this</span>.decodeInt();
  <span class="hljs-keyword">var</span> res = {};
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; nitems; ++i) {
    <span class="hljs-keyword">var</span> key = <span class="hljs-keyword">this</span>.decodeString();
    <span class="hljs-keyword">var</span> val = <span class="hljs-keyword">this</span>.decodeAny();
    res[key] = val;
  }
  <span class="hljs-keyword">return</span> res;
}

BunserBuf.prototype.decodeTemplate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.expectCode(BSER_TEMPLATE);
  <span class="hljs-keyword">var</span> keys = <span class="hljs-keyword">this</span>.decodeArray();
  <span class="hljs-keyword">var</span> nitems = <span class="hljs-keyword">this</span>.decodeInt();
  <span class="hljs-keyword">var</span> arr = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; nitems; ++i) {
    <span class="hljs-keyword">var</span> obj = {};
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> keyidx = <span class="hljs-number">0</span>; keyidx &lt; keys.length; ++keyidx) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.buf.peekInt(<span class="hljs-number">1</span>) == BSER_SKIP) {
        <span class="hljs-keyword">this</span>.buf.readAdvance(<span class="hljs-number">1</span>);
        <span class="hljs-keyword">continue</span>;
      }
      <span class="hljs-keyword">var</span> val = <span class="hljs-keyword">this</span>.decodeAny();
      obj[keys[keyidx]] = val;
    }
    arr.push(obj);
  }
  <span class="hljs-keyword">return</span> arr;
}

BunserBuf.prototype.decodeString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.expectCode(BSER_STRING);
  <span class="hljs-keyword">var</span> len = <span class="hljs-keyword">this</span>.decodeInt();
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.buf.readString(len);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-22" id="section-22"></a>
</div>
<p>This is unusual compared to the other decode functions in that
we may not have enough data available to satisfy the read, and
we don't want to throw.  This is only true when we're reading
the PDU length from the PDU header; we'll set relaxSizeAsserts
in that case.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">BunserBuf.prototype.decodeInt = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">relaxSizeAsserts</span>) </span>{
  <span class="hljs-keyword">if</span> (relaxSizeAsserts &amp;&amp; (<span class="hljs-keyword">this</span>.buf.readAvail() &lt; <span class="hljs-number">1</span>)) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">this</span>.buf.assertReadableSize(<span class="hljs-number">1</span>);
  }
  <span class="hljs-keyword">var</span> code = <span class="hljs-keyword">this</span>.buf.peekInt(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">var</span> size = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">switch</span> (code) {
    <span class="hljs-keyword">case</span> BSER_INT8:
      size = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> BSER_INT16:
      size = <span class="hljs-number">2</span>;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> BSER_INT32:
      size = <span class="hljs-number">4</span>;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> BSER_INT64:
      size = <span class="hljs-number">8</span>;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">this</span>.raise(<span class="hljs-string">"invalid bser int encoding "</span> + code);
  }

  <span class="hljs-keyword">if</span> (relaxSizeAsserts &amp;&amp; (<span class="hljs-keyword">this</span>.buf.readAvail() &lt; <span class="hljs-number">1</span> + size)) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
  <span class="hljs-keyword">this</span>.buf.readAdvance(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.buf.readInt(size);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-23" id="section-23"></a>
</div>
<p>synchronously BSER decode a string and return the value</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadFromBuffer</span>(<span class="hljs-params">input</span>) </span>{
  <span class="hljs-keyword">var</span> buf = <span class="hljs-keyword">new</span> BunserBuf();
  <span class="hljs-keyword">var</span> result = buf.append(input, <span class="hljs-literal">true</span>);
  <span class="hljs-keyword">if</span> (buf.buf.readAvail()) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(
        <span class="hljs-string">'excess data found after input buffer, use BunserBuf instead'</span>);
  }
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">'undefined'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(
        <span class="hljs-string">'no bser found in string and no error raised!?'</span>);
  }
  <span class="hljs-keyword">return</span> result;
}
exports.loadFromBuffer = loadFromBuffer

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-24" id="section-24"></a>
</div>
<p>Byteswap an arbitrary buffer, flipping from one endian
to the other, returning a new buffer with the resultant data</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">byteswap64</span>(<span class="hljs-params">buf</span>) </span>{
  <span class="hljs-keyword">var</span> swap = Buffer.alloc(buf.length);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; buf.length; i++) {
    swap[i] = buf[buf.length <span class="hljs-number">-1</span> - i];
  }
  <span class="hljs-keyword">return</span> swap;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dump_int64</span>(<span class="hljs-params">buf, val</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-25" id="section-25"></a>
</div>
<p>Get the raw bytes.  The Int64 buffer is big endian</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> be = val.toBuffer();

  <span class="hljs-keyword">if</span> (isBigEndian) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-26" id="section-26"></a>
</div>
<p>We're a big endian system, so the buffer is exactly how we
want it to be</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    buf.writeByte(BSER_INT64);
    buf.append(be);
    <span class="hljs-keyword">return</span>;
  }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-27" id="section-27"></a>
</div>
<p>We need to byte swap to get the correct representation</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> le = byteswap64(be);
  buf.writeByte(BSER_INT64);
  buf.append(le);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dump_int</span>(<span class="hljs-params">buf, val</span>) </span>{
  <span class="hljs-keyword">var</span> abs = <span class="hljs-built_in">Math</span>.abs(val);
  <span class="hljs-keyword">if</span> (abs &lt;= MAX_INT8) {
    buf.writeByte(BSER_INT8);
    buf.writeInt(val, <span class="hljs-number">1</span>);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (abs &lt;= MAX_INT16) {
    buf.writeByte(BSER_INT16);
    buf.writeInt(val, <span class="hljs-number">2</span>);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (abs &lt;= MAX_INT32) {
    buf.writeByte(BSER_INT32);
    buf.writeInt(val, <span class="hljs-number">4</span>);
  } <span class="hljs-keyword">else</span> {
    dump_int64(buf, <span class="hljs-keyword">new</span> Int64(val));
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dump_any</span>(<span class="hljs-params">buf, val</span>) </span>{
  <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">typeof</span>(val)) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'number'</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-28" id="section-28"></a>
</div>
<p>check if it is an integer or a float</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isFinite</span>(val) &amp;&amp; <span class="hljs-built_in">Math</span>.floor(val) === val) {
        dump_int(buf, val);
      } <span class="hljs-keyword">else</span> {
        buf.writeByte(BSER_REAL);
        buf.writeDouble(val);
      }
      <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'string'</span>:
      buf.writeByte(BSER_STRING);
      dump_int(buf, Buffer.byteLength(val));
      buf.append(val);
      <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'boolean'</span>:
      buf.writeByte(val ? BSER_TRUE : BSER_FALSE);
      <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'object'</span>:
      <span class="hljs-keyword">if</span> (val === <span class="hljs-literal">null</span>) {
        buf.writeByte(BSER_NULL);
        <span class="hljs-keyword">return</span>;
      }
      <span class="hljs-keyword">if</span> (val <span class="hljs-keyword">instanceof</span> Int64) {
        dump_int64(buf, val);
        <span class="hljs-keyword">return</span>;
      }
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(val)) {
        buf.writeByte(BSER_ARRAY);
        dump_int(buf, val.length);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; val.length; ++i) {
          dump_any(buf, val[i]);
        }
        <span class="hljs-keyword">return</span>;
      }
      buf.writeByte(BSER_OBJECT);
      <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(val);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-29" id="section-29"></a>
</div>
<p>First pass to compute number of defined keys</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> num_keys = keys.length;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; keys.length; ++i) {
        <span class="hljs-keyword">var</span> key = keys[i];
        <span class="hljs-keyword">var</span> v = val[key];
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(v) == <span class="hljs-string">'undefined'</span>) {
          num_keys--;
        }
      }
      dump_int(buf, num_keys);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; keys.length; ++i) {
        <span class="hljs-keyword">var</span> key = keys[i];
        <span class="hljs-keyword">var</span> v = val[key];
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(v) == <span class="hljs-string">'undefined'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-30" id="section-30"></a>
</div>
<p>Don't include it</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">continue</span>;
        }
        dump_any(buf, key);
        <span class="hljs-keyword">try</span> {
          dump_any(buf, v);
        } <span class="hljs-keyword">catch</span> (e) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(
            e.message + <span class="hljs-string">' (while serializing object property with name `'</span> +
              key + <span class="hljs-string">"')"</span>);
        }
      }
      <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'cannot serialize type '</span> + <span class="hljs-keyword">typeof</span>(val) + <span class="hljs-string">' to BSER'</span>);
  }
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-31" id="section-31"></a>
</div>
<p>BSER encode value and return a buffer of the contents</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dumpToBuffer</span>(<span class="hljs-params">val</span>) </span>{
  <span class="hljs-keyword">var</span> buf = <span class="hljs-keyword">new</span> Accumulator();
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-32" id="section-32"></a>
</div>
<p>Build out the header</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  buf.writeByte(<span class="hljs-number">0</span>);
  buf.writeByte(<span class="hljs-number">1</span>);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-33" id="section-33"></a>
</div>
<p>Reserve room for an int32 to hold our PDU length</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  buf.writeByte(BSER_INT32);
  buf.writeInt(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// We'll come back and fill this in at the end</span>

  dump_any(buf, val);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-34" id="section-34"></a>
</div>
<p>Compute PDU length</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> off = buf.writeOffset;
  <span class="hljs-keyword">var</span> len = off - <span class="hljs-number">7</span> <span class="hljs-comment">/* the header length */</span>;
  buf.writeOffset = <span class="hljs-number">3</span>; <span class="hljs-comment">// The length value to fill in</span>
  buf.writeInt(len, <span class="hljs-number">4</span>); <span class="hljs-comment">// write the length in the space we reserved</span>
  buf.writeOffset = off;

  <span class="hljs-keyword">return</span> buf.buf.slice(<span class="hljs-number">0</span>, off);
}
exports.dumpToBuffer = dumpToBuffer

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
