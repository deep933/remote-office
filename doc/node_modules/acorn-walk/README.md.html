<!DOCTYPE html>
<html>
<head>
  <title>README.md</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../doc-style.css" />
  <script src="../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../";
    var thisFile = "node_modules/acorn-walk/README.md";
    var defaultSidebar = true;
  </script>
  <script src="../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

      <div class="heading h1">
        <a href="#acorn-ast-walker">Acorn AST walker</a>
      </div>

      <div class="heading h2">
        <a href="#community">Community</a>
      </div>

      <div class="heading h2">
        <a href="#installation">Installation</a>
      </div>

      <div class="heading h2">
        <a href="#interface">Interface</a>
      </div>

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="docs markdown"><div class="pilwrap" id="acorn-ast-walker">
  <h1>
    <a href="#acorn-ast-walker" name="acorn-ast-walker" class="pilcrow"></a>
Acorn AST walker
  </h1>
</div>
<p>An abstract syntax tree walker for the
<a href="https://github.com/estree/estree">ESTree</a> format.</p>
<div class="pilwrap" id="community">
  <h2>
    <a href="#community" name="community" class="pilcrow"></a>
Community
  </h2>
</div>
<p>Acorn is open source software released under an
<a href="https://github.com/acornjs/acorn/blob/master/acorn-walk/LICENSE">MIT license</a>.</p>
<p>You are welcome to
<a href="https://github.com/acornjs/acorn/issues">report bugs</a> or create pull
requests on <a href="https://github.com/acornjs/acorn">github</a>. For questions
and discussion, please use the
<a href="https://discuss.ternjs.net">Tern discussion forum</a>.</p>
<div class="pilwrap" id="installation">
  <h2>
    <a href="#installation" name="installation" class="pilcrow"></a>
Installation
  </h2>
</div>
<p>The easiest way to install acorn is from <a href="https://www.npmjs.com/"><code>npm</code></a>:</p>
<pre><code class="sh">npm install acorn-walk
</code></pre>
<p>Alternately, you can download the source and build acorn yourself:</p>
<pre><code class="sh">git <span class="hljs-built_in">clone</span> https://github.com/acornjs/acorn.git
<span class="hljs-built_in">cd</span> acorn
npm install
</code></pre>
<div class="pilwrap" id="interface">
  <h2>
    <a href="#interface" name="interface" class="pilcrow"></a>
Interface
  </h2>
</div>
<p>An algorithm for recursing through a syntax tree is stored as an
object, with a property for each tree node type holding a function
that will recurse through such a node. There are several ways to run
such a walker.</p>
<p><strong>simple</strong><code>(node, visitors, base, state)</code> does a 'simple' walk over a
tree. <code>node</code> should be the AST node to walk, and <code>visitors</code> an object
with properties whose names correspond to node types in the <a href="https://github.com/estree/estree">ESTree
spec</a>. The properties should contain
functions that will be called with the node object and, if applicable
the state at that point. The last two arguments are optional. <code>base</code>
is a walker algorithm, and <code>state</code> is a start state. The default
walker will simply visit all statements and expressions and not
produce a meaningful state. (An example of a use of state is to track
scope at each point in the tree.)</p>
<pre><code class="js"><span class="hljs-keyword">const</span> acorn = <span class="hljs-built_in">require</span>(<span class="hljs-string">"acorn"</span>)
<span class="hljs-keyword">const</span> walk = <span class="hljs-built_in">require</span>(<span class="hljs-string">"acorn-walk"</span>)

walk.simple(acorn.parse(<span class="hljs-string">"let x = 10"</span>), {
  Literal(node) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Found a literal: <span class="hljs-subst">${node.value}</span>`</span>)
  }
})
</code></pre>
<p><strong>ancestor</strong><code>(node, visitors, base, state)</code> does a 'simple' walk over
a tree, building up an array of ancestor nodes (including the current node)
and passing the array to the callbacks as a third parameter.</p>
<pre><code class="js"><span class="hljs-keyword">const</span> acorn = <span class="hljs-built_in">require</span>(<span class="hljs-string">"acorn"</span>)
<span class="hljs-keyword">const</span> walk = <span class="hljs-built_in">require</span>(<span class="hljs-string">"acorn-walk"</span>)

walk.ancestor(acorn.parse(<span class="hljs-string">"foo('hi')"</span>), {
  Literal(_, ancestors) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"This literal's ancestors are:"</span>, ancestors.map(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n.type))
  }
})
</code></pre>
<p><strong>recursive</strong><code>(node, state, functions, base)</code> does a 'recursive'
walk, where the walker functions are responsible for continuing the
walk on the child nodes of their target node. <code>state</code> is the start
state, and <code>functions</code> should contain an object that maps node types
to walker functions. Such functions are called with <code>(node, state, c)</code>
arguments, and can cause the walk to continue on a sub-node by calling
the <code>c</code> argument on it with <code>(node, state)</code> arguments. The optional
<code>base</code> argument provides the fallback walker functions for node types
that aren't handled in the <code>functions</code> object. If not given, the
default walkers will be used.</p>
<p><strong>make</strong><code>(functions, base)</code> builds a new walker object by using the
walker functions in <code>functions</code> and filling in the missing ones by
taking defaults from <code>base</code>.</p>
<p><strong>full</strong><code>(node, callback, base, state)</code> does a 'full' walk over a
tree, calling the callback with the arguments (node, state, type) for
each node</p>
<p><strong>fullAncestor</strong><code>(node, callback, base, state)</code> does a 'full' walk
over a tree, building up an array of ancestor nodes (including the
current node) and passing the array to the callbacks as a third
parameter.</p>
<pre><code class="js"><span class="hljs-keyword">const</span> acorn = <span class="hljs-built_in">require</span>(<span class="hljs-string">"acorn"</span>)
<span class="hljs-keyword">const</span> walk = <span class="hljs-built_in">require</span>(<span class="hljs-string">"acorn-walk"</span>)

walk.full(acorn.parse(<span class="hljs-string">"1 + 1"</span>), node =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`There's a <span class="hljs-subst">${node.type}</span> node at <span class="hljs-subst">${node.ch}</span>`</span>)
})
</code></pre>
<p><strong>findNodeAt</strong><code>(node, start, end, test, base, state)</code> tries to locate
a node in a tree at the given start and/or end offsets, which
satisfies the predicate <code>test</code>. <code>start</code> and <code>end</code> can be either <code>null</code>
(as wildcard) or a number. <code>test</code> may be a string (indicating a node
type) or a function that takes <code>(nodeType, node)</code> arguments and
returns a boolean indicating whether this node is interesting. <code>base</code>
and <code>state</code> are optional, and can be used to specify a custom walker.
Nodes are tested from inner to outer, so if two nodes match the
boundaries, the inner one will be preferred.</p>
<p><strong>findNodeAround</strong><code>(node, pos, test, base, state)</code> is a lot like
<code>findNodeAt</code>, but will match any node that exists 'around' (spanning)
the given position.</p>
<p><strong>findNodeAfter</strong><code>(node, pos, test, base, state)</code> is similar to
<code>findNodeAround</code>, but will match all nodes <em>after</em> the given position
(testing outer nodes before inner nodes).</p>
</div>
  </div>
</body>
</html>
