<!DOCTYPE html>
<html>
<head>
  <title>index.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../doc-style.css" />
  <script src="../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../";
    var thisFile = "node_modules/acorn-jsx/index.js";
    var defaultSidebar = true;
  </script>
  <script src="../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>index.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">const</span> XHTMLEntities = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./xhtml'</span>);

<span class="hljs-keyword">const</span> hexNumber = <span class="hljs-regexp">/^[\da-fA-F]+$/</span>;
<span class="hljs-keyword">const</span> decimalNumber = <span class="hljs-regexp">/^\d+$/</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<p>The map to <code>acorn-jsx</code> tokens from <code>acorn</code> namespace objects.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">const</span> acornJsxMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<p>Get the original tokens for the given <code>acorn</code> namespace object.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getJsxTokens</span>(<span class="hljs-params">acorn</span>) </span>{
  acorn = acorn.Parser.acorn || acorn;
  <span class="hljs-keyword">let</span> acornJsx = acornJsxMap.get(acorn);
  <span class="hljs-keyword">if</span> (!acornJsx) {
    <span class="hljs-keyword">const</span> tt = acorn.tokTypes;
    <span class="hljs-keyword">const</span> TokContext = acorn.TokContext;
    <span class="hljs-keyword">const</span> TokenType = acorn.TokenType;
    <span class="hljs-keyword">const</span> tc_oTag = <span class="hljs-keyword">new</span> TokContext(<span class="hljs-string">'&lt;tag'</span>, <span class="hljs-literal">false</span>);
    <span class="hljs-keyword">const</span> tc_cTag = <span class="hljs-keyword">new</span> TokContext(<span class="hljs-string">'&lt;/tag'</span>, <span class="hljs-literal">false</span>);
    <span class="hljs-keyword">const</span> tc_expr = <span class="hljs-keyword">new</span> TokContext(<span class="hljs-string">'&lt;tag&gt;...&lt;/tag&gt;'</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>);
    <span class="hljs-keyword">const</span> tokContexts = {
      <span class="hljs-attr">tc_oTag</span>: tc_oTag,
      <span class="hljs-attr">tc_cTag</span>: tc_cTag,
      <span class="hljs-attr">tc_expr</span>: tc_expr
    };
    <span class="hljs-keyword">const</span> tokTypes = {
      <span class="hljs-attr">jsxName</span>: <span class="hljs-keyword">new</span> TokenType(<span class="hljs-string">'jsxName'</span>),
      <span class="hljs-attr">jsxText</span>: <span class="hljs-keyword">new</span> TokenType(<span class="hljs-string">'jsxText'</span>, {<span class="hljs-attr">beforeExpr</span>: <span class="hljs-literal">true</span>}),
      <span class="hljs-attr">jsxTagStart</span>: <span class="hljs-keyword">new</span> TokenType(<span class="hljs-string">'jsxTagStart'</span>, {<span class="hljs-attr">startsExpr</span>: <span class="hljs-literal">true</span>}),
      <span class="hljs-attr">jsxTagEnd</span>: <span class="hljs-keyword">new</span> TokenType(<span class="hljs-string">'jsxTagEnd'</span>)
    };

    tokTypes.jsxTagStart.updateContext = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">this</span>.context.push(tc_expr); <span class="hljs-comment">// treat as beginning of JSX expression</span>
      <span class="hljs-keyword">this</span>.context.push(tc_oTag); <span class="hljs-comment">// start opening tag context</span>
      <span class="hljs-keyword">this</span>.exprAllowed = <span class="hljs-literal">false</span>;
    };
    tokTypes.jsxTagEnd.updateContext = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prevType</span>) </span>{
      <span class="hljs-keyword">let</span> out = <span class="hljs-keyword">this</span>.context.pop();
      <span class="hljs-keyword">if</span> (out === tc_oTag &amp;&amp; prevType === tt.slash || out === tc_cTag) {
        <span class="hljs-keyword">this</span>.context.pop();
        <span class="hljs-keyword">this</span>.exprAllowed = <span class="hljs-keyword">this</span>.curContext() === tc_expr;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">this</span>.exprAllowed = <span class="hljs-literal">true</span>;
      }
    };

    acornJsx = { <span class="hljs-attr">tokContexts</span>: tokContexts, <span class="hljs-attr">tokTypes</span>: tokTypes };
    acornJsxMap.set(acorn, acornJsx);
  }

  <span class="hljs-keyword">return</span> acornJsx;
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p>Transforms JSX element name to string.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getQualifiedJSXName</span>(<span class="hljs-params">object</span>) </span>{
  <span class="hljs-keyword">if</span> (!object)
    <span class="hljs-keyword">return</span> object;

  <span class="hljs-keyword">if</span> (object.type === <span class="hljs-string">'JSXIdentifier'</span>)
    <span class="hljs-keyword">return</span> object.name;

  <span class="hljs-keyword">if</span> (object.type === <span class="hljs-string">'JSXNamespacedName'</span>)
    <span class="hljs-keyword">return</span> object.namespace.name + <span class="hljs-string">':'</span> + object.name.name;

  <span class="hljs-keyword">if</span> (object.type === <span class="hljs-string">'JSXMemberExpression'</span>)
    <span class="hljs-keyword">return</span> getQualifiedJSXName(object.object) + <span class="hljs-string">'.'</span> +
    getQualifiedJSXName(object.property);
}

<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{
  options = options || {};
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Parser</span>) </span>{
    <span class="hljs-keyword">return</span> plugin({
      <span class="hljs-attr">allowNamespaces</span>: options.allowNamespaces !== <span class="hljs-literal">false</span>,
      <span class="hljs-attr">allowNamespacedObjects</span>: !!options.allowNamespacedObjects
    }, Parser);
  };
};

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<p>This is <code>tokTypes</code> of the peer dep.
This can be different instances from the actual <code>tokTypes</code> this plugin uses.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">module</span>.exports, <span class="hljs-string">"tokTypes"</span>, {
  <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get_tokTypes</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> getJsxTokens(<span class="hljs-built_in">require</span>(<span class="hljs-string">"acorn"</span>)).tokTypes;
  },
  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>
});

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">plugin</span>(<span class="hljs-params">options, Parser</span>) </span>{
  <span class="hljs-keyword">const</span> acorn = Parser.acorn || <span class="hljs-built_in">require</span>(<span class="hljs-string">"acorn"</span>);
  <span class="hljs-keyword">const</span> acornJsx = getJsxTokens(acorn);
  <span class="hljs-keyword">const</span> tt = acorn.tokTypes;
  <span class="hljs-keyword">const</span> tok = acornJsx.tokTypes;
  <span class="hljs-keyword">const</span> tokContexts = acorn.tokContexts;
  <span class="hljs-keyword">const</span> tc_oTag = acornJsx.tokContexts.tc_oTag;
  <span class="hljs-keyword">const</span> tc_cTag = acornJsx.tokContexts.tc_cTag;
  <span class="hljs-keyword">const</span> tc_expr = acornJsx.tokContexts.tc_expr;
  <span class="hljs-keyword">const</span> isNewLine = acorn.isNewLine;
  <span class="hljs-keyword">const</span> isIdentifierStart = acorn.isIdentifierStart;
  <span class="hljs-keyword">const</span> isIdentifierChar = acorn.isIdentifierChar;

  <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parser</span> </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<p>Expose actual <code>tokTypes</code> and <code>tokContexts</code> to other plugins.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">static</span> <span class="hljs-keyword">get</span> acornJsx() {
      <span class="hljs-keyword">return</span> acornJsx;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<p>Reads inline JSX contents token.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    jsx_readToken() {
      <span class="hljs-keyword">let</span> out = <span class="hljs-string">''</span>, chunkStart = <span class="hljs-keyword">this</span>.pos;
      <span class="hljs-keyword">for</span> (;;) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.pos &gt;= <span class="hljs-keyword">this</span>.input.length)
          <span class="hljs-keyword">this</span>.raise(<span class="hljs-keyword">this</span>.start, <span class="hljs-string">'Unterminated JSX contents'</span>);
        <span class="hljs-keyword">let</span> ch = <span class="hljs-keyword">this</span>.input.charCodeAt(<span class="hljs-keyword">this</span>.pos);

        <span class="hljs-keyword">switch</span> (ch) {
        <span class="hljs-keyword">case</span> <span class="hljs-number">60</span>: <span class="hljs-comment">// '&lt;'</span>
        <span class="hljs-keyword">case</span> <span class="hljs-number">123</span>: <span class="hljs-comment">// '{'</span>
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.pos === <span class="hljs-keyword">this</span>.start) {
            <span class="hljs-keyword">if</span> (ch === <span class="hljs-number">60</span> &amp;&amp; <span class="hljs-keyword">this</span>.exprAllowed) {
              ++<span class="hljs-keyword">this</span>.pos;
              <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishToken(tok.jsxTagStart);
            }
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getTokenFromCode(ch);
          }
          out += <span class="hljs-keyword">this</span>.input.slice(chunkStart, <span class="hljs-keyword">this</span>.pos);
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishToken(tok.jsxText, out);

        <span class="hljs-keyword">case</span> <span class="hljs-number">38</span>: <span class="hljs-comment">// '&amp;'</span>
          out += <span class="hljs-keyword">this</span>.input.slice(chunkStart, <span class="hljs-keyword">this</span>.pos);
          out += <span class="hljs-keyword">this</span>.jsx_readEntity();
          chunkStart = <span class="hljs-keyword">this</span>.pos;
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-number">62</span>: <span class="hljs-comment">// '&gt;'</span>
        <span class="hljs-keyword">case</span> <span class="hljs-number">125</span>: <span class="hljs-comment">// '}'</span>
          <span class="hljs-keyword">this</span>.raise(
            <span class="hljs-keyword">this</span>.pos,
            <span class="hljs-string">"Unexpected token `"</span> + <span class="hljs-keyword">this</span>.input[<span class="hljs-keyword">this</span>.pos] + <span class="hljs-string">"`. Did you mean `"</span> +
              (ch === <span class="hljs-number">62</span> ? <span class="hljs-string">"&amp;gt;"</span> : <span class="hljs-string">"&amp;rbrace;"</span>) + <span class="hljs-string">"` or "</span> + <span class="hljs-string">"`{\""</span> + <span class="hljs-keyword">this</span>.input[<span class="hljs-keyword">this</span>.pos] + <span class="hljs-string">"\"}"</span> + <span class="hljs-string">"`?"</span>
          );

        <span class="hljs-keyword">default</span>:
          <span class="hljs-keyword">if</span> (isNewLine(ch)) {
            out += <span class="hljs-keyword">this</span>.input.slice(chunkStart, <span class="hljs-keyword">this</span>.pos);
            out += <span class="hljs-keyword">this</span>.jsx_readNewLine(<span class="hljs-literal">true</span>);
            chunkStart = <span class="hljs-keyword">this</span>.pos;
          } <span class="hljs-keyword">else</span> {
            ++<span class="hljs-keyword">this</span>.pos;
          }
        }
      }
    }

    jsx_readNewLine(normalizeCRLF) {
      <span class="hljs-keyword">let</span> ch = <span class="hljs-keyword">this</span>.input.charCodeAt(<span class="hljs-keyword">this</span>.pos);
      <span class="hljs-keyword">let</span> out;
      ++<span class="hljs-keyword">this</span>.pos;
      <span class="hljs-keyword">if</span> (ch === <span class="hljs-number">13</span> &amp;&amp; <span class="hljs-keyword">this</span>.input.charCodeAt(<span class="hljs-keyword">this</span>.pos) === <span class="hljs-number">10</span>) {
        ++<span class="hljs-keyword">this</span>.pos;
        out = normalizeCRLF ? <span class="hljs-string">'\n'</span> : <span class="hljs-string">'\r\n'</span>;
      } <span class="hljs-keyword">else</span> {
        out = <span class="hljs-built_in">String</span>.fromCharCode(ch);
      }
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.locations) {
        ++<span class="hljs-keyword">this</span>.curLine;
        <span class="hljs-keyword">this</span>.lineStart = <span class="hljs-keyword">this</span>.pos;
      }

      <span class="hljs-keyword">return</span> out;
    }

    jsx_readString(quote) {
      <span class="hljs-keyword">let</span> out = <span class="hljs-string">''</span>, chunkStart = ++<span class="hljs-keyword">this</span>.pos;
      <span class="hljs-keyword">for</span> (;;) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.pos &gt;= <span class="hljs-keyword">this</span>.input.length)
          <span class="hljs-keyword">this</span>.raise(<span class="hljs-keyword">this</span>.start, <span class="hljs-string">'Unterminated string constant'</span>);
        <span class="hljs-keyword">let</span> ch = <span class="hljs-keyword">this</span>.input.charCodeAt(<span class="hljs-keyword">this</span>.pos);
        <span class="hljs-keyword">if</span> (ch === quote) <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">if</span> (ch === <span class="hljs-number">38</span>) { <span class="hljs-comment">// '&amp;'</span>
          out += <span class="hljs-keyword">this</span>.input.slice(chunkStart, <span class="hljs-keyword">this</span>.pos);
          out += <span class="hljs-keyword">this</span>.jsx_readEntity();
          chunkStart = <span class="hljs-keyword">this</span>.pos;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isNewLine(ch)) {
          out += <span class="hljs-keyword">this</span>.input.slice(chunkStart, <span class="hljs-keyword">this</span>.pos);
          out += <span class="hljs-keyword">this</span>.jsx_readNewLine(<span class="hljs-literal">false</span>);
          chunkStart = <span class="hljs-keyword">this</span>.pos;
        } <span class="hljs-keyword">else</span> {
          ++<span class="hljs-keyword">this</span>.pos;
        }
      }
      out += <span class="hljs-keyword">this</span>.input.slice(chunkStart, <span class="hljs-keyword">this</span>.pos++);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishToken(tt.string, out);
    }

    jsx_readEntity() {
      <span class="hljs-keyword">let</span> str = <span class="hljs-string">''</span>, count = <span class="hljs-number">0</span>, entity;
      <span class="hljs-keyword">let</span> ch = <span class="hljs-keyword">this</span>.input[<span class="hljs-keyword">this</span>.pos];
      <span class="hljs-keyword">if</span> (ch !== <span class="hljs-string">'&amp;'</span>)
        <span class="hljs-keyword">this</span>.raise(<span class="hljs-keyword">this</span>.pos, <span class="hljs-string">'Entity must start with an ampersand'</span>);
      <span class="hljs-keyword">let</span> startPos = ++<span class="hljs-keyword">this</span>.pos;
      <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.pos &lt; <span class="hljs-keyword">this</span>.input.length &amp;&amp; count++ &lt; <span class="hljs-number">10</span>) {
        ch = <span class="hljs-keyword">this</span>.input[<span class="hljs-keyword">this</span>.pos++];
        <span class="hljs-keyword">if</span> (ch === <span class="hljs-string">';'</span>) {
          <span class="hljs-keyword">if</span> (str[<span class="hljs-number">0</span>] === <span class="hljs-string">'#'</span>) {
            <span class="hljs-keyword">if</span> (str[<span class="hljs-number">1</span>] === <span class="hljs-string">'x'</span>) {
              str = str.substr(<span class="hljs-number">2</span>);
              <span class="hljs-keyword">if</span> (hexNumber.test(str))
                entity = <span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-built_in">parseInt</span>(str, <span class="hljs-number">16</span>));
            } <span class="hljs-keyword">else</span> {
              str = str.substr(<span class="hljs-number">1</span>);
              <span class="hljs-keyword">if</span> (decimalNumber.test(str))
                entity = <span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-built_in">parseInt</span>(str, <span class="hljs-number">10</span>));
            }
          } <span class="hljs-keyword">else</span> {
            entity = XHTMLEntities[str];
          }
          <span class="hljs-keyword">break</span>;
        }
        str += ch;
      }
      <span class="hljs-keyword">if</span> (!entity) {
        <span class="hljs-keyword">this</span>.pos = startPos;
        <span class="hljs-keyword">return</span> <span class="hljs-string">'&amp;'</span>;
      }
      <span class="hljs-keyword">return</span> entity;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-8" id="section-8"></a>
</div>
<p>Read a JSX identifier (valid tag or attribute name).</p>
<p>Optimized version since JSX identifiers can't contain
escape characters and so can be read as single slice.
Also assumes that first character was already checked
by isIdentifierStart in readToken.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    jsx_readWord() {
      <span class="hljs-keyword">let</span> ch, start = <span class="hljs-keyword">this</span>.pos;
      <span class="hljs-keyword">do</span> {
        ch = <span class="hljs-keyword">this</span>.input.charCodeAt(++<span class="hljs-keyword">this</span>.pos);
      } <span class="hljs-keyword">while</span> (isIdentifierChar(ch) || ch === <span class="hljs-number">45</span>); <span class="hljs-comment">// '-'</span>
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishToken(tok.jsxName, <span class="hljs-keyword">this</span>.input.slice(start, <span class="hljs-keyword">this</span>.pos));
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-9" id="section-9"></a>
</div>
<p>Parse next token as JSX identifier</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    jsx_parseIdentifier() {
      <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.startNode();
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.type === tok.jsxName)
        node.name = <span class="hljs-keyword">this</span>.value;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.type.keyword)
        node.name = <span class="hljs-keyword">this</span>.type.keyword;
      <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">this</span>.unexpected();
      <span class="hljs-keyword">this</span>.next();
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">'JSXIdentifier'</span>);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-10" id="section-10"></a>
</div>
<p>Parse namespaced identifier.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    jsx_parseNamespacedName() {
      <span class="hljs-keyword">let</span> startPos = <span class="hljs-keyword">this</span>.start, startLoc = <span class="hljs-keyword">this</span>.startLoc;
      <span class="hljs-keyword">let</span> name = <span class="hljs-keyword">this</span>.jsx_parseIdentifier();
      <span class="hljs-keyword">if</span> (!options.allowNamespaces || !<span class="hljs-keyword">this</span>.eat(tt.colon)) <span class="hljs-keyword">return</span> name;
      <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>.startNodeAt(startPos, startLoc);
      node.namespace = name;
      node.name = <span class="hljs-keyword">this</span>.jsx_parseIdentifier();
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">'JSXNamespacedName'</span>);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-11" id="section-11"></a>
</div>
<p>Parses element name in any form - namespaced, member
or single identifier.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    jsx_parseElementName() {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.type === tok.jsxTagEnd) <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
      <span class="hljs-keyword">let</span> startPos = <span class="hljs-keyword">this</span>.start, startLoc = <span class="hljs-keyword">this</span>.startLoc;
      <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.jsx_parseNamespacedName();
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.type === tt.dot &amp;&amp; node.type === <span class="hljs-string">'JSXNamespacedName'</span> &amp;&amp; !options.allowNamespacedObjects) {
        <span class="hljs-keyword">this</span>.unexpected();
      }
      <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.eat(tt.dot)) {
        <span class="hljs-keyword">let</span> newNode = <span class="hljs-keyword">this</span>.startNodeAt(startPos, startLoc);
        newNode.object = node;
        newNode.property = <span class="hljs-keyword">this</span>.jsx_parseIdentifier();
        node = <span class="hljs-keyword">this</span>.finishNode(newNode, <span class="hljs-string">'JSXMemberExpression'</span>);
      }
      <span class="hljs-keyword">return</span> node;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-12" id="section-12"></a>
</div>
<p>Parses any type of JSX attribute value.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    jsx_parseAttributeValue() {
      <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.type) {
      <span class="hljs-keyword">case</span> tt.braceL:
        <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.jsx_parseExpressionContainer();
        <span class="hljs-keyword">if</span> (node.expression.type === <span class="hljs-string">'JSXEmptyExpression'</span>)
          <span class="hljs-keyword">this</span>.raise(node.start, <span class="hljs-string">'JSX attributes must only be assigned a non-empty expression'</span>);
        <span class="hljs-keyword">return</span> node;

      <span class="hljs-keyword">case</span> tok.jsxTagStart:
      <span class="hljs-keyword">case</span> tt.string:
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseExprAtom();

      <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">this</span>.raise(<span class="hljs-keyword">this</span>.start, <span class="hljs-string">'JSX value should be either an expression or a quoted JSX text'</span>);
      }
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-13" id="section-13"></a>
</div>
<p>JSXEmptyExpression is unique type since it doesn't actually parse anything,
and so it should start at the end of last read token (left brace) and finish
at the beginning of the next one (right brace).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    jsx_parseEmptyExpression() {
      <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.startNodeAt(<span class="hljs-keyword">this</span>.lastTokEnd, <span class="hljs-keyword">this</span>.lastTokEndLoc);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNodeAt(node, <span class="hljs-string">'JSXEmptyExpression'</span>, <span class="hljs-keyword">this</span>.start, <span class="hljs-keyword">this</span>.startLoc);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-14" id="section-14"></a>
</div>
<p>Parses JSX expression enclosed into curly brackets.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    jsx_parseExpressionContainer() {
      <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.startNode();
      <span class="hljs-keyword">this</span>.next();
      node.expression = <span class="hljs-keyword">this</span>.type === tt.braceR
        ? <span class="hljs-keyword">this</span>.jsx_parseEmptyExpression()
        : <span class="hljs-keyword">this</span>.parseExpression();
      <span class="hljs-keyword">this</span>.expect(tt.braceR);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">'JSXExpressionContainer'</span>);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-15" id="section-15"></a>
</div>
<p>Parses following JSX attribute name-value pair.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    jsx_parseAttribute() {
      <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.startNode();
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eat(tt.braceL)) {
        <span class="hljs-keyword">this</span>.expect(tt.ellipsis);
        node.argument = <span class="hljs-keyword">this</span>.parseMaybeAssign();
        <span class="hljs-keyword">this</span>.expect(tt.braceR);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">'JSXSpreadAttribute'</span>);
      }
      node.name = <span class="hljs-keyword">this</span>.jsx_parseNamespacedName();
      node.value = <span class="hljs-keyword">this</span>.eat(tt.eq) ? <span class="hljs-keyword">this</span>.jsx_parseAttributeValue() : <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">'JSXAttribute'</span>);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-16" id="section-16"></a>
</div>
<p>Parses JSX opening tag starting after '&lt;'.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    jsx_parseOpeningElementAt(startPos, startLoc) {
      <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.startNodeAt(startPos, startLoc);
      node.attributes = [];
      <span class="hljs-keyword">let</span> nodeName = <span class="hljs-keyword">this</span>.jsx_parseElementName();
      <span class="hljs-keyword">if</span> (nodeName) node.name = nodeName;
      <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.type !== tt.slash &amp;&amp; <span class="hljs-keyword">this</span>.type !== tok.jsxTagEnd)
        node.attributes.push(<span class="hljs-keyword">this</span>.jsx_parseAttribute());
      node.selfClosing = <span class="hljs-keyword">this</span>.eat(tt.slash);
      <span class="hljs-keyword">this</span>.expect(tok.jsxTagEnd);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, nodeName ? <span class="hljs-string">'JSXOpeningElement'</span> : <span class="hljs-string">'JSXOpeningFragment'</span>);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-17" id="section-17"></a>
</div>
<p>Parses JSX closing tag starting after '&lt;/'.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    jsx_parseClosingElementAt(startPos, startLoc) {
      <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.startNodeAt(startPos, startLoc);
      <span class="hljs-keyword">let</span> nodeName = <span class="hljs-keyword">this</span>.jsx_parseElementName();
      <span class="hljs-keyword">if</span> (nodeName) node.name = nodeName;
      <span class="hljs-keyword">this</span>.expect(tok.jsxTagEnd);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, nodeName ? <span class="hljs-string">'JSXClosingElement'</span> : <span class="hljs-string">'JSXClosingFragment'</span>);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-18" id="section-18"></a>
</div>
<p>Parses entire JSX element, including it's opening tag
(starting after '&lt;'), attributes, contents and closing tag.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    jsx_parseElementAt(startPos, startLoc) {
      <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.startNodeAt(startPos, startLoc);
      <span class="hljs-keyword">let</span> children = [];
      <span class="hljs-keyword">let</span> openingElement = <span class="hljs-keyword">this</span>.jsx_parseOpeningElementAt(startPos, startLoc);
      <span class="hljs-keyword">let</span> closingElement = <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">if</span> (!openingElement.selfClosing) {
        <span class="hljs-attr">contents</span>: <span class="hljs-keyword">for</span> (;;) {
          <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.type) {
          <span class="hljs-keyword">case</span> tok.jsxTagStart:
            startPos = <span class="hljs-keyword">this</span>.start; startLoc = <span class="hljs-keyword">this</span>.startLoc;
            <span class="hljs-keyword">this</span>.next();
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eat(tt.slash)) {
              closingElement = <span class="hljs-keyword">this</span>.jsx_parseClosingElementAt(startPos, startLoc);
              <span class="hljs-keyword">break</span> contents;
            }
            children.push(<span class="hljs-keyword">this</span>.jsx_parseElementAt(startPos, startLoc));
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> tok.jsxText:
            children.push(<span class="hljs-keyword">this</span>.parseExprAtom());
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> tt.braceL:
            children.push(<span class="hljs-keyword">this</span>.jsx_parseExpressionContainer());
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">this</span>.unexpected();
          }
        }
        <span class="hljs-keyword">if</span> (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
          <span class="hljs-keyword">this</span>.raise(
            closingElement.start,
            <span class="hljs-string">'Expected corresponding JSX closing tag for &lt;'</span> + getQualifiedJSXName(openingElement.name) + <span class="hljs-string">'&gt;'</span>);
        }
      }
      <span class="hljs-keyword">let</span> fragmentOrElement = openingElement.name ? <span class="hljs-string">'Element'</span> : <span class="hljs-string">'Fragment'</span>;

      node[<span class="hljs-string">'opening'</span> + fragmentOrElement] = openingElement;
      node[<span class="hljs-string">'closing'</span> + fragmentOrElement] = closingElement;
      node.children = children;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.type === tt.relational &amp;&amp; <span class="hljs-keyword">this</span>.value === <span class="hljs-string">"&lt;"</span>) {
        <span class="hljs-keyword">this</span>.raise(<span class="hljs-keyword">this</span>.start, <span class="hljs-string">"Adjacent JSX elements must be wrapped in an enclosing tag"</span>);
      }
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishNode(node, <span class="hljs-string">'JSX'</span> + fragmentOrElement);
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-19" id="section-19"></a>
</div>
<p>Parse JSX text</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    jsx_parseText() {
      <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.parseLiteral(<span class="hljs-keyword">this</span>.value);
      node.type = <span class="hljs-string">"JSXText"</span>;
      <span class="hljs-keyword">return</span> node;
    }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-20" id="section-20"></a>
</div>
<p>Parses entire JSX element from current position.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    jsx_parseElement() {
      <span class="hljs-keyword">let</span> startPos = <span class="hljs-keyword">this</span>.start, startLoc = <span class="hljs-keyword">this</span>.startLoc;
      <span class="hljs-keyword">this</span>.next();
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.jsx_parseElementAt(startPos, startLoc);
    }

    parseExprAtom(refShortHandDefaultPos) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.type === tok.jsxText)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.jsx_parseText();
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.type === tok.jsxTagStart)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.jsx_parseElement();
      <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.parseExprAtom(refShortHandDefaultPos);
    }

    readToken(code) {
      <span class="hljs-keyword">let</span> context = <span class="hljs-keyword">this</span>.curContext();

      <span class="hljs-keyword">if</span> (context === tc_expr) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.jsx_readToken();

      <span class="hljs-keyword">if</span> (context === tc_oTag || context === tc_cTag) {
        <span class="hljs-keyword">if</span> (isIdentifierStart(code)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.jsx_readWord();

        <span class="hljs-keyword">if</span> (code == <span class="hljs-number">62</span>) {
          ++<span class="hljs-keyword">this</span>.pos;
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishToken(tok.jsxTagEnd);
        }

        <span class="hljs-keyword">if</span> ((code === <span class="hljs-number">34</span> || code === <span class="hljs-number">39</span>) &amp;&amp; context == tc_oTag)
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.jsx_readString(code);
      }

      <span class="hljs-keyword">if</span> (code === <span class="hljs-number">60</span> &amp;&amp; <span class="hljs-keyword">this</span>.exprAllowed &amp;&amp; <span class="hljs-keyword">this</span>.input.charCodeAt(<span class="hljs-keyword">this</span>.pos + <span class="hljs-number">1</span>) !== <span class="hljs-number">33</span>) {
        ++<span class="hljs-keyword">this</span>.pos;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.finishToken(tok.jsxTagStart);
      }
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.readToken(code);
    }

    updateContext(prevType) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.type == tt.braceL) {
        <span class="hljs-keyword">var</span> curContext = <span class="hljs-keyword">this</span>.curContext();
        <span class="hljs-keyword">if</span> (curContext == tc_oTag) <span class="hljs-keyword">this</span>.context.push(tokContexts.b_expr);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (curContext == tc_expr) <span class="hljs-keyword">this</span>.context.push(tokContexts.b_tmpl);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">super</span>.updateContext(prevType);
        <span class="hljs-keyword">this</span>.exprAllowed = <span class="hljs-literal">true</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.type === tt.slash &amp;&amp; prevType === tok.jsxTagStart) {
        <span class="hljs-keyword">this</span>.context.length -= <span class="hljs-number">2</span>; <span class="hljs-comment">// do not consider JSX expr -&gt; JSX open tag -&gt; ... anymore</span>
        <span class="hljs-keyword">this</span>.context.push(tc_cTag); <span class="hljs-comment">// reconsider as closing tag context</span>
        <span class="hljs-keyword">this</span>.exprAllowed = <span class="hljs-literal">false</span>;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.updateContext(prevType);
      }
    }
  };
}

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
